### MVVM
#### 1. MVC
- M model 数据
- V view 视图
- C controller 控制器

> 当用户改变页面时，会触发控制器，控制器会调用数据，将数据展示到对应的视图上，V->C->M->V

#### 2. MVVM
- M model 数据
- V view 视图
- VM viewModel 视图模型

> 先将数据绑定在视图上，会监听视图的改变，视图改变后会触发数据的变化，这种实现是通过viewModel

### 数组方法
1) find方法是es6中的方法(不兼容)       查询
- 在数组中查找，如果返回true表示找到了，找到后会将当前item返回，如果没找到则返回undefined
- 查找到后停止循环
```javascript
var arr = [{name: 1}, {name: 2}, {name: 3}, {name: 2}];
var newB = arr.find(function (item) {
   return item.name == 2;
});
console.log(newB);
```

2) map 映射 将一个数组 变成另一个模样   修改
- 返回值是新数组，不会改变原数组，会将返回的值替换掉当前项
```javascript
var fruits = ['苹果', '草莓', '西瓜'];
var newArr = fruits.map(function (item) {
    return `<li>${item}</li>`;
});
console.log(newArr.join(''));
```

3) filter过滤 返回一个新数组
- 在函数中返回true表示这一项留下,返回false表示这一项删除掉
```javascript
var arr = [{name: 1}, {name: 2}, {name: 3}, {name: 2}];
var newA = arr.filter(function (item) {
    return item.name != 2;  //如果想删除某一项 都用!=
});
console.log(newA);
```
4) for in/forEach/for of的区别
- for in
    1. key是字符串类型的
    2. for in会遍历私有和公有属性(不想遍历的私有属性也会被遍历出来)
- for of
    1. 可以跳出循环 
    2. 只会遍历数组中的内容 
    3. 缺点 不能遍历对象
```javascript
var arr = [1,2,3,4];
arr.name = 'jw';
for(var value of arr){ // value代表数组的每一项
   if(value == 3) break; //可以跳出循环
   console.log(100);
}
```

5) reduce 收敛
- 返回的结果是 多次叠加后的操作，你可以自己制定首次默认的第一项是多少
```javascript
var arr = [1,2,3,4,5,6];
var n = 0;
var result = arr.reduce(function (prev,next) {
    //上一个默认是数组的第一项，下一个默认是数组的第二项
    //上一个变成第一次返回的结果，下一个就是第三项
    console.log(prev,next);
    return prev+next;
},50);
console.log(result);
```
- 二维数组  二维数组扁平化
```javascript
var arr = [['北京'],['上海'],['广州']];
//=> ['北京'，'上海','广州']
var result = arr.reduce(function (prev,next) {
    // prev ['北京'] next['上海']
    // prev['北京','上海'] next['广州']
    return prev.concat(next);
});
console.log(result);
```

### 压缩和不压缩的区别(vue.min.js)
- 压缩后在写代码时，没有任何的警告。一般开发时选择为压缩版

### vue
- v-model (双向数据绑定，只能在表单上使用，将数据绑定在表单元素上，如果表单内容更改，会导致数据变化)
- v-html (可以将字符串的html转换成html)
- v-once (数据绑定一次，随后数据变化，不更新视图变化)
- v-text (和{{}}用法一致，用来将数据显示在视图上，防止单个元素闪烁)
- v-for (循环数据、对象、字符串 v-for="value of或者in items")
- v-on (可以绑定事件 v-on:事件名="函数名",可以把v-on简写成@符号)
- v-show/v-if (控制元素的显示和隐藏，v-show控制的是样式 v-if控制的是dom的增加和删除)

### 初始化的数据必须要定义后才能修改使用
1. 初始化的数据必须要定义后才能修改使用
2. 对象的属性上不能存在的数据不会报错，不能增加以前没有的属性,
3. 实例可以创建多个（一般只有一个）
4. {{}} 表达式中不能写js语法，可以赋值 运算 三元，展示返回的结果
5. {{}} 在大括号中默认放的都是变量

```html
<div id="app">
    <p>{{message}}</p>

    <p>{{ hello==0 ? 'yes' : 'no' }}</p>

    <p><input type="text" v-model="message"></p>

    <div v-html="html"></div>

    <div v-once>{{message}}</div>

    <div v-text="message"></div>
</div>
```

```javascript
var vm = new Vue({
    el: '#app', // 可以指定vue的应用范围，不能给body和html
    data: {
        message: 'hello vue.js',
        hello: 0,
        html: '<h3>试下v-html</h3>'
    }
}); // viewModel, 数据要挂在vm上才可以实现MVVM
// vm 会代理data中的所有数据 vm.message  Object.defineProperty
console.log(vm.message);
// 初始化的数据必须要定义后才能修改使用
```

### Vue的指令
1. 双向绑定 v-model 可以将数据绑定到视图上，当视图改变时，可以数据更改
2. 只有表单元素可以更改视图 input radio checkbox textarea select (只有这5个可以增加v-model指令 只能放置表达式)
3. v-html 将字符串展示成html (不要绑定到用户可以输入的元素上)
4. v-once 只让数据绑定一次， 在数据更新不再刷新视图
5. v-text 用法和 {{}} 一样，不会闪烁,默认属性是不会展示在页面上的，当vue数据渲染完成后会替换掉div中的内容

### v-for
1. data是数据 可以是任意类型（函数不要在这里声明）
2. 循环数组，要循环谁，就在谁身上写v-for, 可以使用 in 或者 of
3. 可以遍历数组 字符串 对象

### event事件
1. 根组件，在vue中操作的都是数据 不是DOM元素
2. v-on代表的是指令可以用来绑定事件,绑定事件执行括号，不需要传递参数则不加 v-on:keyup="addFruits"
3. v-on:keyup 可以简写为 @keyup
4. 在vue中methods中的方法里的this指向都是vm(实例)
5. 如果写绑定的函数加 () 需要手动传入事件源$event
6. v-show 操作的是css样式，如果不满足条件则display: none
7. v-if操作的dom元素，默认不满足条件时 dom不存在，满足后则增加dom元素
8. 频繁操作显示和隐藏，使用v-show

### 修饰符
1. 按键修饰符，vue提供了大量的按键修饰符 space esc left right ... 可以用keyCode代替
2. a: 65  enter: 13
3. 当keyCode 等于写的值的时候触发事件
4. 事件冒泡: 阻止冒泡 .stop
   事件捕获: 将事件模式变成捕获 .capture
   只自己触发: .self
   阻止默认事件: .prevent
5. 修饰符可以累加使用
6. .once 绑定一次，执行一次后解绑事件
7. 绑定动态数据用v-bind 简写 :

### 动态绑定class style 样式
1. 动态绑定的class和原生的class 可以共存,动态覆盖静态
2. 对象绑定方式  {样式：条件，样式1：条件}
3. 数组绑定方式
4. 对象 + 数组
5. 绑定动态属
6. 动态绑定的class和原生的class 可以共存,动态覆盖静态
```html
<!---->
<div class="back" :class="{font:flag}">红色背景</div>

<div :class="[b, {font:flag}, 'box']">红色背景</div>

<div :style="{background:'green',fontSize:'50px'}">绿色</div>
<div :style="[s1, s2]">行内样式</div>
```
```javascript
var vm = new Vue({
    el: '#app',
    data: {
        flag: false,
        b: 'back',
        c: 'font',
        s1: {background: 'limegreen'},
        s2: {color: 'yellow'}
    }
});
```

### computed 计算属性
1. 计算"属性" 不是方法 可以根据已有属性 推断出一个新的属性来
```
{{ sum() }}
```
> 如果这样绑定，时刻监听 数据的变化，只要有数据边，不管和sum函数有没有关系都会执行
2. 计算属性，根据某个值计算出新值，当这个值变化后会重新计算，别的数据改变不会收到影响
```html
<div id="app">
    {{ sum }}
    价格 {{ price }}
    数量 <input type="text" v-model="count">
    名字 <input type="text" v-model="name">
</div>
```
```javascript
var vm = new Vue({
    el: '#app',
    data: {
        price: 100,
        count: 10,
        name: '飞机'
    },
    methods: {},
    computed: {
        // sum属性由两部分组成 （获取，设置）
        sum: {
            get() { // 展示就是获取
                // 如果price和count变化会导致 sum变化
                return this.price * this.count;
            },
            set(val) {  // vm.sum = 100;
                // sum变化有可能会改变name变化，computed属性中this依然是vm
            }
        }
    }
});
```

### 全选和反选
1. 点击全选可以控制 下面的所有checkbox，如果有一个chekbox没选中 全选为不选中状态
2. 全选的值依赖于下面的checkbox，如果都为true则选中，给全选赋值要改变下面的checkbox的值
```
全选 <input type="checkbox" v-model="checkAll"><br>
    <input type="checkbox" v-for="check in checkList" v-model="check.isChecked">
```
```javascript
var vm = new Vue({
    el: '#app',
    data: {
        checkList: [{isChecked: true}, {isChecked: true}, {isChecked: true}]
    },
    methods: {},
    computed: {
        checkAll: {
            get() {
                return this.checkList.every((item) => {
                    return item.isChecked;
                });
            },
            set(val) {
                for (let v of this.checkList) {
                    v.isChecked = val;
                }
            }
        }
    }
});
```

### watch
```javascript
var vm = new Vue({
    el: '#app',
    data: {
        message: 'hello',
        content: ''
    },
    watch: {
        message(newValue, oldValue) {
            this.content = '等待中...';
            setTimeout(function () {
                vm.content = newValue + ', maxin';
            }, 2000);
        }
    }
});
```
1. computed 适合做复杂逻辑，简单的只能给watch,当一个值改变触发某件事时，使用watch
2. 如果是"异步"并且有"中间过程"，用watch
3. methods watch computed 区别
> 一般来说watch方法只能监听一级,如果需要深度监听
```javascript
watch() {
    todos: {
        handler() {
            // 将todos存到本地 设置key和value, value会被自动toString
            localStorage.setItem('todos', JSON.stringify(this.todos));
        },
        deep: true  // 深度监控,只要todos有变化，就会执行此监控
    }
}
```

### vue生命周期
- 针对的是组件，根组件也是组件，仍然遵循这个流程
```javascript
var vm = new Vue({
    el: '.app',
    data: {message: 'hello'},
    msg: 'world',
    beforeCreate() { alert('创建之前') },
    created() { alert('创建完成') },
    beforeMount() { alert('开始挂载') },
    mounted() { alert('挂载完成') },
    beforeUpdate() { alert('开始更新') },
    updated() { alert('更新之后') },
    beforeDestroy() { alert('销毁之前') },
    destroyed() { alert('销毁之后') },
});
 vm.$mount('.app');  // 等价于写el: '.app'
 //vm.$destroy();  // 销毁组件
 console.log(vm.$data); // 就是data这整个对象
 console.log(vm.$options.msg); // 在实例上自定义数据，没有放在data中的
 // 所有带$的都是vue内部属性，vue提供的
```
- 钩子函数：每个阶段都会调用这个函数
1. beforeCreate() => 创建之前 一般不使用
2. created() => 创建完成后 可以获取数据
3. beforeMount() => 开始挂载
4. mounted() => 挂载完成 在mounted中也可以获取数据 页面加载完成会调用此函数

-> 更新 拦截 数据更新就会调用这两个函数
5. beforeUpdate() => 开始更新
6. updated() => 更新之后

7. beforeDestroy() => 销毁之前
8. destroyed() => 销毁之后

### directives
- 自定义指令：v-自定义指令-用横杠连接
```javascript
directives: {
    autoFocus(ele, bindings) {
        if (bindings.value) {
            ele.focus();
        }
    }
}
```
ele代表的是input元素, bindings.value 代表的是 currentTodo==todo的结果

### H5本地存储 localStorage
```javascript
localStorage.setItem('todos', JSON.stringify(this.todos));
JSON.parse(localStorage.getItem('todos'));
localStorage.removeItem('todos');   // 移除
```
将数据以键值对的方式存储在浏览器本地

### hash值变化事件
```javascript
let listener = function () {
    // 当hash值变化时会执行次函数，将当前hash值赋予给state
    vm.state = window.location.hash.slice(1) || 'complete';
}
listener();
window.addEventListener('hashchange', listener, false);
```
通过更改锚点，模拟改变页面路由 => 'hashchange'

### vue中的组件
#### 组件化开发
> 可以很直观的将一个复杂的页面分割成若干个独立组件,每个组件包含自己的逻辑和样式 再将这些独立组件组合完成一个复杂的页面。 这样既减少了逻辑复杂度，又实现了代码的重用。 页面是组件的容器，组件自由组合形成完整的界面，当不需要某个组件时，或者想要替换某个组件时，可以随时进行替换和删除，而不影响整个应用的运行

好处：
1. 提高开发效率
2. 方便重复使用
3. 便于协同开发
4. 更容易被管理和维护

#### 全局注册
1. 在标签中不能使用大写，标签名字多个单词时必须用段横线隔开
2. 全局注册 在所有实例中都可以使用这个组件
3. 组件需要行为 结构 数据
4. 组件的模版中只能有一个根元素

```html
<div id="app">
    <my-component></my-component>
</div>

<div id="app1">
    <my-component></my-component>
</div>

<template id="hello">
    <div>
        <div>Hello</div>
        <div>World</div>
    </div>
</template>
```
```javascript
Vue.component('myComponent', {
    template: '#hello'  // 通过模版的id可以引用这个组件
});
var vm = new Vue({});
vm.$mount('#app');

var vm1 = new Vue({
    el: '#app1'
});
```

#### 组件
1. 子组件不能直接使用父组件的数据
2. 可以在子组件中自己声明数据
3. 子组件定义数据必须是函数类型
```html
<div id="app">
    <!--这里的模板标签名只能是用短横线连接-->
    <my-component></my-component>
</div>
```
```javascript
var vm = new Vue({
    el: '#app',
    data: {msg: 'hello'},
    components: {
        'my-component': {   // // 短横线或者驼峰
            template: `<h3>{{ msg }}</h3>`,
            data() {    // 子组件定义数据必须是函数类型
                return {msg: 'world'}
            }
        }
    }
});
```

#### 组件中的数据
1. 声明组件的名字，不能为已存在的标签 比如名字叫 a p div
2. 每个组件应该是没关系的，都应该产生自己的数据
3. 在组件中使用的方法和默认的vm是一样的，只是data不再是对象而是函数
4. 子组件中各个方法中的this都是子组件本身
5. 组件可以无限嵌套
6. 子组件要在父组件的模版中使用
```html
<!--水果 > 甜的 > 西瓜-->
<div id="app">
    <fruit></fruit>
</div>
```
```javascript
var vm = new Vue({
    el: '#app',
    components: {
        fruit: {
            template: `<div>水果 <sweet></sweet></div>`
        },
        components: {
            sweet: {
                template: `<div>甜的 <water-malon></water-malon></div>`
            },
            components: {
                waterMalon: {
                    template: `<div>西瓜</div>`
                }
            }
        }
    }
});
```
> 不过一般不要像上面这样去写，嵌套的层数太多，可读性太差，把组件对应的对象提到外面写比较好

```javascript
var waterMalon = {
    template: '<div>西瓜</div>'
};
var sweet = {
    template: '<div>甜的 <water-malon></water-malon></div>',
    components: {
        waterMalon: waterMalon
    }
};
var fruit = {
    template: `<div>水果 <sweet></sweet></div>`,
    components: {
        sweet: sweet
    }
};
var vm = new Vue({
    el: '#app',
    components: {
        fruit: fruit
    }
});
```

> 模版中的html元素的根节点只能有一个

### 组件之间的数据通信
#### 父传子
- 父组件要将数据传递给子组件，子组件要将内部发生的事情通知父组件
- 不能在子组件中直接调用父组件中的数据，需要通过父组件的属性传递
- 组件要显示的通过props声明传递过来的属性。

```html
<div id="app">
    <!--如果直接写-->
    <!--动态数据使用v-bind 简写为 :-->
    <child :foods="meat" :greens="vegetables"></child>
</div>
```
```javascript
var vm = new Vue({
    el: '#app',
    data: {
        meat: '猪肉',
        vegetables: '蔬菜'
    },
    components: {
        child: {
            props: ['foods', 'greens'], // foods,greens相当于是子组件的数据了
            computed: {
                rou() {
                    return '加工后的' + this.foods;
                }
                /*data() { // 或者用data改变子组件的数据
                    return {meat: '加工后的' + this.foods};
                }*/
            },
            template: `<div>儿子做{{ rou }}、{{ greens }}吃  <grandson :vegetables="greens"></grandson></div>`,
            components: {
                grandson: {
                    props: ['vegetables'],
                    template: `<div>孙子做{{ vegetables }}吃</div>`
                }
            }
        }
    }
});
```

#### 父传子时props可以验证
1. required: true 表示属性必须传递
2. type: 可以使用的类型
3. default: 默认值，不传递的情况下使用默认值，传了使用传递的值
4. validator(val): val是形参 该属性传的是什么val的值就是什么,返回false校验失败
```html
<div id="app">
    <child :c="201"></child>
</div>
```
```javascript
var vm = new Vue({
    el: '#app',
    data: {count: 100},
    components: {
        child: {
            // 自定义验证器
            props: {
                c: {
                    type: [Number, String, Boolean],
                    default: '待定',
                    validator(val) {
                        return val > 200;
                    }
                }
            },
            template: `<div>子组件 数量{{ c }}</div>`
        }
    }
});
```

#### 子传父
> 子组件需要通过事件发射($emit)触发父组件的自定义事件
```html
<div id="app">
    <div v-if="m">爸爸有 {{ m }}</div>
    <!--儿子$emit后会触发自己身上的have-money方法，对应的函数是父亲身上的,儿子触发父亲的函数-->
    <child @have-money="say"></child>
</div>

<template id="child">
    <div>
        儿子有 {{ money }}
        <button type="button" @click="tell">告诉爸爸我有多少钱</button>
    </div>
</template>
```
```javascript
var child = {
    template: '#child',
    data() {
        return {money: 100}
    },
    methods: {
        tell() {
            this.$emit('have-money', this.money);
        }
    }
};
var vm = new Vue({
    el: '#app',
    data: {m: ''},
    components: {child},
    methods: {
        say(data) {
            this.m = data;
        }
    }
});
```

#### 平级组件间的通信
1. 事件车，通过事件车的方式传递数据 eventBus
2. 实例上 有$emit $on
3. 创建一个实例 让需要互相通信的平级组件 共用一个事件机制

```html
<div id="app">
    <bro-one></bro-one>
    <bro-two></bro-two>
</div>
```
```javascript
var bus = new Vue();

var broOne = {
    template: `<div>大兄弟 <button @click="sendFood">给小兄弟送吃的</button></div>`,
    data() {
        return {food: '猪肉'}
    },
    methods: {
        sendFood() {
            bus.$emit('送吃的', this.food);
        }
    }
};
var broTwo = {
    mounted() {
        // 如果不处理下，这个函数中的this指定的不是broTwo
        bus.$on('送吃的', data => this.meat = data);
    },
    data() {
        return {meat: '黄瓜'};
    },
    template: `<div>小兄弟吃 {{ meat }}</div>`
};
var vm = new Vue({
    el: '#app',
    components: {broOne, broTwo}
});
```

#### 子组件更改数据方式
- 可以作为数据的初始值使用
```
data(){
    return {msg:this.language + 'hello'}
}
```
- 作为子组件的computed属性
```
computed: {
    msg() {
        return this.language + 'hello'
    }
}
```

### slot插槽
- 可以在组件内定制模板,在使用组件时会将中间传递的内容替换掉定制的模板。
1. 单个slot
```html
<my-component>
    <!--这里不传入内容时默认会使用模版中定制的内容，传入后会覆盖掉定制的内容-->
    <div>用这个盒子替换掉slot</div>
</my-component>
```
```
components: {
    'my-component': {
        template: `<div>
                <slot>
                    <h1>这是小标题</h1>
                    <p>这是内容</p>
                </slot>
            </div>`
    }
}
```
2. 具名slot
- 通过组件中传入模版，每个模版指定slot名字，这个名字和定制的模版匹配到，会替换定制的模版
- 模版中指定结构位置的元素标签为 slot,对应一个name属性，并指定值
- 在页面中的组件标签里面添加内容，内容元素有一个slot属性，该slot属性的值与模版中slot标签上name属性的值一一对应
```html
<div id="app">
    <alert>
        <div slot="footer">这是弹窗的底部</div>
        <div>
            <strong>错误</strong>
            <p>出bug了</p>
        </div>
        <div slot="header">这是弹窗的头部</div>
        <div>xxxx</div>
    </alert>
</div>
```
```javascript
var vm = new Vue({
    el: '#app',
    components: {
        alert: {
            template: `<div class="alert alert-danger">
                    <slot name="header"></slot>
                    <slot>这是一个alert弹窗</slot>
                    <slot name="footer"></slot>
                </div>`
        }
    }
});
```

#### panel 组件
```html
<div id="app">
    <panel 
            :has-btn="true" 
            :type="'info'" 
            :author="name"
            @say-title="fn">
        <div slot="heading">Vue.js</div>
        <div>
            <h3>组件的数据交互</h3>
            <ul>
                <li>父->子组件</li>
                <li>子->父组件</li>
                <li>兄弟数据传递</li>
            </ul>
        </div>
    </panel>
</div>

<template id="panel">
    <div class="panel" :class="[sty]">
        <div class="panel-heading">
            <slot name="heading">README.md</slot>
        </div>
        <div class="panel-body">
            <slot>这是默认的内容...</slot>
        </div>
        <div class="panel-footer">
            <button 
                    type="button" 
                    class="btn btn-danger" 
                    v-if="hasBtn" 
                    @click="say">点我说标题</button>
            {{ author }}
        </div>
    </div>
</template>
```

```javascript
 // 不能直接更改父级数据 this.type = this.type + 1
var panel = {
    template: '#panel',
    computed: {
        sty() {
            return 'panel-' + this.type;
        }
    },
    /*data() {
        return {sty: 'panel-' + this.type};
    },*/
    props: {
        // type类型是父类传入的类型，想要的是type是 panel-info
        type: {default: 'success'},
        hasBtn: {default: true, type: Boolean},
        author: {default: 'sb', type: String}
    },
    methods: {
        say() {
            this.$emit('say-title', this.author);
        }
    }
}
var vm = new Vue({
    el: '#app',
    data: {name: 'maxin'},
    methods: {
        fn(auth) {
            alert(auth)
        }
    },
    components: {panel}
});
```

> 不指定slot名字默认名字为default,可以和具名slot同时使用

#### recursive 递归组件
- 自己调自己，必须要有中断条件 树 有子节点
- 默认情况下递归组件是不执行的，要指定name属性(只在局部组件中需要加)
```html
<div id="app">
    <tree :datas="datas"></tree>
</div>
```
```javascript
var vm = new Vue({
    el: '#app',
    data: {
        datas: {
            name: '父亲',
            children: [
                {
                    name: '大儿子',
                    children: [
                        {name: '大孙子'},
                        {
                            name: '中孙子',
                            children: [
                                {name: '大曾孙'},
                                {name: '小曾孙'}
                            ]
                        },
                        {name: '小孙子'}
                    ]
                },
                {name: '小儿子'}
            ]
        }
    },
    components: {
        tree: {
            name: 'tree',
            props: ['datas'],
            template: `<ul>
                        <li>{{ datas.name }}
                            <tree v-for="child in datas.children" :datas="child"></tree>
                        </li>
                       </ul>`,
        }
    }
});
```

#### is模版
1. is可以指定当前标签内插入什么元素
2. is可以防止解析出错
3. template 没有意义 component 组件标签 is是谁就会显示哪个组件
4. radio中 默认没有绑定数据 要给value值，这个value值会映射到radio上，如果v-model和value相等则被选中
```html
<input type="radio" v-model="rad" value="home">
<input type="radio" v-model="rad" value="list">

<keep-alive>
    <component :is="rad"></component>
</keep-alive>
```
> keep-alive标签是 缓存组件的上一次的状态，防止每次切换时重新渲染数据

```javascript
var vm = new Vue({
    el: '#app',
    data: {rad: 'home'},
    components: {
        home: {
            template: '<div @click="changeColor" ref="h">Home</div>',
            methods: {
                changeColor(e) {
                    // 操作DOM的api，尽量不要使用
                    this.$refs.h.style.background = 'red';
                    // e.target.style.background = 'red'
                }
            }
        },
        list: {
            template: '<div>List</div>'
        }
    }
});
```

### vue中的路由

- 基本路由
- 不同的路径 返回不同的内容
- spa 不同的路径显示不同的组件
```html
<div id="app">
    <router-link to="/home">home</router-link>
    <router-link to="/list">list</router-link>
    <router-view></router-view>
</div>
```
```javascript
var home = {template: '<div>首页</div>'};
var list = {template: '<div>列表页</div>'};
const routes = [
    {path: '/home', component: home},
    {path: '/list', component: list}
];
var router = new VueRouter({ routes });
var vm = new Vue({ router }).$mount('#app');
```

#### router-link
1) to
- router-link标签模版编译后默认会自动转换成a标签，
- to 表示目标路由的链接。
- 当被点击后，内部会立刻把 to 的值传到 router.push()
- 这个值可以是一个字符串或者是描述目标位置的对象
- 子路由的链接字符串不能加"/", "/"代表根路径
```html
<router-link to="/home">首页</router-link>

<router-link :to="{path: '/food'}">food</router-link>

<!-- 命名的路由 -->
<router-link :to="{name:'user', params:{userId:123}}">User</router-link>

<!--查询参数-->
<router-link :to="{path:'register', query:{plan:'private'}">regester</router-link>
```

2) tag
- 不想默认让router-link是a标签，加上tag="li"
```html
<router-link :to="{path: '/food'}" tag="li">food</router-link>
```


#### 动态路由匹配
```javascript
const User = {
  template: '<div>User {{ $route.params.id }}</div>'
}

const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头
    { path: '/user/:id', component: User }
  ]
})
```
- 把路径设置成动态的 /user/:id 这样，访问的url是 /user/3 也是可以匹配到的
- 调用 vm.$route.params 可以得到一个对象 {id: 3}
- 复杂一点的 /user/:username/post/:post_id => /user/evan/post/123 => { username: 'evan', post_id: 123 }
- 除了$route.params外 还有 $route.query  $route.hash 等
- this.$route (这里存放的都是关于路由的信息) 
- this.$router (这里存放的是路由的方法)

#### 嵌套路由
- template标签包裹的内容必须只能拥有一个根节点